import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.ListIterator;
import java.util.Scanner;

public class HW1 {
	public static void normal(List[] user) {
		ListIterator<Contents> litr;
		Contents ss;
		for (int i = 0; i < user.length; i++) {
			if (user[i].size() == 0)
				continue;
			double average = 0;
			litr = user[i].listIterator();
			while (litr.hasNext()) {
				ss = litr.next();
				average += ss.score;
			}
			average /= user[i].size();

			while (litr.hasPrevious()) {
				ss = litr.previous();
				ss.score -= average;
				litr.set(ss);
			}
		}
	}

	public static LinkedList<Contents> similarity(List[] user, int target, int n) {
		AlphaSort al = new AlphaSort();
		ScoreSort sc = new ScoreSort();
		Contents s1, s2;
		LinkedList<Contents> arr = new LinkedList<Contents>();
		LinkedList<Contents> use = new LinkedList<Contents>();

		double sumTarget, sumOther, multi, value;
		int i = 0, cmp, remem;

		while (i < user.length) {
			if (target == i || user[i].size() == 0) {
				i++;
				continue;
			}

			multi = 0;
			value = 0;
			sumTarget = 0;
			sumOther = 0;
			remem = 0;

			for (int k = 0; k < user[i].size(); k++) {
				s2 = (Contents) user[i].get(k);
				sumOther += (s2.score * s2.score);
			}

			for (int j = 0; j < user[target].size(); j++) {
				s1 = (Contents) user[target].get(j);
				sumTarget += (s1.score * s1.score);
				for (int k = remem; k < user[i].size(); k++) {
					s2 = (Contents) user[i].get(k);
					cmp = al.compare(s1, s2);
					if (cmp == 0) {
						value += (s1.score * s2.score);
						remem = k + 1;
						break;
					}
				}
			}
			i++;
			value /= (Math.sqrt(sumOther) * Math.sqrt(sumTarget));
			if (Double.isNaN(value))
				value = 0;

			arr.add(new Contents((Integer.toString(i - 1)), value));
		}
		Collections.sort(arr, sc.reversed());
		for (int k = 0; k < n; k++) {
			s1 = arr.get(k);
			use.add(s1);
		}
		return use;
	}

	public static void recommend(List[] user, LinkedList<Contents> arr, int target, int k) {
		Contents s1, s2, s3;
		AlphaSort al = new AlphaSort();
		ScoreSort sc = new ScoreSort();
		LinkedList<Contents> prop = new LinkedList<Contents>();
		int id, scmp, cmp, count, remem, flag;

		// 추천 시스템 구축해야되는데 이게 target과 해당 id 간에 같은 것들은 새로만든 prop에서 remove하면 되지만, 다음 id의
		// 배열에서
		// prop과 같은 경우는 더해주는 건 쉽지만, 다른 경우 추가해줘야됨. 하지만, 다른 경우에 대해 여러가지 고려사항이 존재.(
		for (int k = 0; k < arr.size(); k++) {
			id = Integer.parseInt(arr.get(k).content);
			// id 할당
			remem = 0;

			for (int i = 0; i < user[id].size(); i++) { // 그 id에 대해 반복문
				s1 = (Contents) user[id].get(i);
				flag = 0;
				for (int t = remem; t < prop.size(); t++) { // id의 내용과 prop의 내용이 겹치면 더하기
					s2 = prop.get(t);
					scmp = al.compare(s1, s2);
					if (scmp < 0) // id : a0 , prop : b2 인 경우 / 현재 for 문이 끝나고 id for문이 돌 때
						remem = k + 1;
					else if (scmp == 0) // 같으면 거기에 score만 더하기
					{
						flag = 1;
						s2.score += (s1.score * arr.get(k).score);
						prop.set(t, s2);
						break;
					}
				}
				if (flag == 0) { // 같은 게 없으면 추가
					prop.add(s1);
				}

			}

			for (int j = 0; j < user[target].size(); j++) {
				s1 = (Contents) user[target].get(j);
				for (int i = remem; i < user[id].size(); i++) {
					s2 = (Contents) user[id].get(i);
					cmp = al.compare(s1, s2);
					if (cmp == 0) {
						prop.remove(i);
						remem = i;
						break;
					}
				}
			}

		}
		Collections.sort(prop, sc.reversed());
		System.out.println("prop: ");
		for (int h = 0; h < k; h++) {
			s3 = prop.get(h);
			System.out.println(s3.content + " " + s3.score);
		}
	}

	public static void prtNormal(List[] user, int target) {
		ListIterator<Contents> litr;
		litr = user[target].listIterator();
		Contents ss;
		System.out.print("1. 사용자 " + target + "의 콘텐츠와 정규화 점수:\n   ");
		System.out.print("[");
		while (litr.hasNext()) {
			ss = litr.next();
			System.out.printf("(%s, %.3f)", ss.content, ss.score);
			if (litr.hasNext()) {
				System.out.print(", ");
			}
		}
		System.out.println("]");
	}

	public static void prtSimilarity(LinkedList<Contents> arr) {
		System.out.println("2. 유사한 사용자 id와 유사도 리스트");
		for (int j = 0; j < arr.size(); j++) {
			System.out.printf("   사용자 id: %s, 유사도 : %.6f\n", arr.get(j).content, arr.get(j).score);
		}
	}

	public static void main(String[] args) throws NumberFormatException, IOException {
		System.out.print("파일 이름, target 사용자, 참고인 수, 항목 수? ");
		Scanner in = new Scanner(System.in);
		String fileName = in.next();
		String line;
		AlphaSort al = new AlphaSort();
		int target = in.nextInt();
		int n = in.nextInt();
		int k = in.nextInt();

		in.close();

		FileReader fileReader = null;
		try {
			fileReader = new FileReader(fileName);
		} catch (FileNotFoundException e) {
			e.printStackTrace();
		}
		BufferedReader bufferedReader = new BufferedReader(fileReader);

		int num = Integer.parseInt(bufferedReader.readLine());
		List user[] = new List[num];

		for (int i = 0; i < num; i++)
			user[i] = new LinkedList<Contents>();

		while ((line = bufferedReader.readLine()) != null) {
			String token[] = line.split(" ");
			int flag = 0;
			Contents ss = new Contents(token[1], Double.parseDouble(token[2])), sss;

			for (int j = 0; j < user[Integer.parseInt(token[0])].size(); j++) {
				sss = (Contents) user[Integer.parseInt(token[0])].get(j);
				if (sss.content.equals(ss.content)) {
					user[Integer.parseInt(token[0])].set(j, ss);
					flag = 1;
				}
			}
			if (flag == 0)
				user[Integer.parseInt(token[0])].add(new Contents(token[1], Double.parseDouble(token[2])));
		}
		for (int i = 0; i < num; i++)
			Collections.sort(user[i], al);

		normal(user);
		prtNormal(user, target);
		LinkedList<Contents> arr = similarity(user, target, n);
		prtSimilarity(arr);
		recommend(user, arr, target, k);
	}
}

class AlphaSort implements Comparator<Contents> {
	public int compare(Contents a, Contents b) {
		String eng1 = a.content.substring(0, 1);
		String eng2 = b.content.substring(0, 1);

		int cmp = eng1.compareTo(eng2);
		if (cmp == 0) {
			int num1 = Integer.parseInt(a.content.substring(1));
			int num2 = Integer.parseInt(b.content.substring(1));

			cmp = Integer.compare(num1, num2);
		}
		return cmp;
	}
}

class ScoreSort implements Comparator<Contents> {
	public int compare(Contents a, Contents b) {
		return Double.compare(a.score, b.score);
	}
}

class Contents {
	String content;
	double score;

	Contents(String content, double score) {
		this.content = content;
		this.score = score;
	}
}